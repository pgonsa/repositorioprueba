<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="stylesprueba.css">
    <title>Software life cycle</title>
</head>
<body>
    <h1>Software Life Cycle</h1>
    <br>
    <br>
    <p>
        The Software Development Life Cycle is a reference to an established process whereby software progresses through various distinctive phases revolving around development, testing, and deployment. The Software Development Life Cycle is employed to establish a systematic approach to software design, improvement, and testing.It allows for a more organized product and can help improve quality, resource management and reduce risks.

        In essence, a computer program growth lifestyle is a roadmap for dealing with a digital option. In other words, it is a plan that enables a group to create, sustain, and deal with digital products. The actions of a computer program growth lifestyle procedure rely on project sizing and project objectives. Each step also outlines how it must be accomplished. Normally, every development team builds its own computer program growth cycle, or adopts one of the models.

    </p>
    <section>
        <h2>Cascade model</h2>
    <br>
    <p>

        The Cascade (Waterfall) Model is a linear, sequential software development approach. Each phase must be completed before moving to the next, with little overlap.
    </p>
    <br>
    <h3>Phases</h3>
    <br>
    <ol>
        <li>Requirement Gathering: All project requirements are defined upfront.</li>
        <li>System Design: System architecture and specifications are created.</li>
        <li>Implementation: Developers code based on design.</li>
        <li>Integration & Testing: The system is integrated and tested for bugs.</li>
        <li>Deployment: The final system is delivered to users.</li>
        <li>Maintenance: Post-deployment support, including bug fixes and updates.</li>
    </ol>
    <br>
    <h3>Advantages</h3>
    <br>
    <ul>
        <li>Simple and easy to manage.</li>
        <li>Well-structured with clear phases and deliverables.</li>
    </ul>
    <br>
    <h3>Disadvantages</h3>
    <br>
    <ul>
        <li>Inflexible to changes after development starts.</li>
        <li>Late testing can lead to costly rework.</li>
        <li>No early working software.</li>
    </ul>
    </section>
    <section>
        <h2>Iterative model</h2>
    <br>
    <p>
        The Iterative Model focuses on repeating (iterating) the development cycle until the desired software is achieved. In this approach, the software is developed in smaller portions, and each iteration improves or refines previous versions of the software. Itâ€™s particularly useful when requirements are not well understood at the start of the project.
    </p>
    <br>
    <h3>Key points</h3>
    <br>
    <ul>
        <li>Initial Version: A simple initial version of the system is built.</li>
        <li>Feedback: Feedback is gathered after each iteration.</li>
        <li>Improvement: Each iteration incorporates improvements based on feedback.</li>
        <li>Refinement: Over multiple cycles, the system evolves and becomes more refined.</li>
    </ul>
    <br>
    <h3>Advantages</h3>
    <br>
    <ul>
        <li>Early visibility of progress.</li>
        <li>Easier to incorporate changes.</li>
        <li>Allows partial implementation before the final system is completed.</li>
    </ul>
    <br>
    <h3>Disadvantages</h3>
    <br>
    <ul>
        <li>Can lead to scope creep if not carefully managed.</li>
        <li>Not all requirements may be considered in the initial cycles.</li>
    </ul>
    <br>
    </section>
    <section>
        <h2>Incremental development</h2>
        <br>
        <p>
            In the Incremental Development Model, the software is developed and delivered in small, manageable chunks called increments. Each increment represents a working part of the software, with subsequent increments adding more functionality. The final system is a sum of all the increments.
        </p>
        <br>
        <h3>Key points</h3>
        <br>
        <ul>
            <li>Build in Increments: The system is built incrementally.</li>
            <li>Working Software at Each Stage: Each increment delivers working software.</li>
            <li>Prioritization: Important features are developed and delivered first.</li>
            <li>Integration: New increments are integrated with previous versions.</li>
        </ul>
        <br>
        <h3>Advantages</h3>
        <br>
        <ul>
            <li>Functional software is delivered earlier.</li>
            <li>More flexible in accommodating changes.</li>
            <li>Easier to test and validate each increment.</li>
        </ul>
        <br>
        <h3>Disadvantages</h3>
        <br>
        <ul>
            <li>May lead to fragmented systems if increments are not well planned.</li>
            <li>Dependencies between increments can complicate the development process.</li>
        </ul>
        <br>
    </section>
    <section>
        <h2>Spiral model</h2>
    <br>
    <p>
        The Spiral Model combines elements of both the iterative and waterfall models, emphasizing risk management at every stage. It is designed to help manage uncertainty and risk in large, complex projects. The development process spirals through phases: planning, risk analysis, engineering, and evaluation, with each loop focusing on a specific set of activities.
    </p>
    <br>
    <h3>Key points</h3>
    <br>
    <ul>
        <li>Risk-Driven: Risk analysis and management is central to the process.</li>
        <li>Multiple Phases: The spiral repeats with different objectives in each loop (e.g., prototypes, detailed design, etc.).</li>
        <li>Customer Feedback: Regular feedback from the customer is used to refine each phase.</li>
        <li>Iterative Nature: The software evolves with each iteration of the spiral.</li>
    </ul>
    <br>
    <h3>Advantages</h3>
    <br>
    <ul>
        <li>Emphasizes risk analysis and management.</li>
        <li>Flexible and adaptable to changes.</li>
        <li>Suited for large and complex projects.</li>
    </ul>
    <br>
    <h3>Disadvantages</h3>
    <br>
    <ul>
        <li>Can be costly due to repeated phases.</li>
        <li>Requires highly skilled project management.</li>
        <li>Not suitable for small projects with low risk.</li>
    </ul>
    <br>
    </section>
    <section>
        <h2>Prototype model</h2>
    <br>
    <p>
        In the Prototype Model, a prototype or an early model of the system is built and shown to stakeholders for feedback. This model is not a fully functional system but a representation of the key features and functionalities. After receiving feedback, the prototype is refined, and development continues until the final product is completed.
    </p>
    <br>
    <h3>Key points</h3>
    <br>
    <ul>
        <li>Prototype Development: An initial prototype is developed based on user requirements.</li>
        <li>User Feedback: Stakeholders review and provide feedback on the prototype.</li>
        <li>Refinement: The prototype is refined iteratively until a satisfactory system is achieved.</li>
        <li>Final Development: Once the prototype is accepted, the actual system is developed.</li>
    </ul>
    <br>
    <h3>Advantages</h3>
    <br>
    <ul>
        <li>Helps clarify requirements early.</li>
        <li>Reduces the risk of misunderstandings between developers and users.</li>
        <li>Encourages stakeholder involvement.</li>
    </ul>
    <br>
    <h3>Disadvantages</h3>
    <br>
    <ul>
        <li>May lead to excessive refinement cycles.</li>
        <li>Can be time-consuming if the prototype is too detailed.</li>
        <li>Focus on prototype development may delay actual system development.</li>
    </ul>
    </section>

    <br>
    <p>
        These models vary in how they address change, risk, and feedback during the software development process. The choice of model depends on project requirements, team experience, and risk management needs.
    </p>
    <br>
</body>
</html>